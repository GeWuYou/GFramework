using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using GFramework.SourceGenerators.Abstractions.logging;
using GFramework.SourceGenerators.Common.constants;
using GFramework.SourceGenerators.Common.extensions;
using GFramework.SourceGenerators.Common.generator;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace GFramework.SourceGenerators.logging;

/// <summary>
///     日志生成器，用于为标记了LogAttribute的类自动生成日志字段
/// </summary>
[Generator]
public sealed class LoggerGenerator : TypeAttributeClassGeneratorBase
{
    /// <summary>
    ///     获取属性元数据的完整名称，用于标识日志属性的完全限定名
    /// </summary>
    protected override Type AttributeType => typeof(LogAttribute);

    /// <summary>
    ///     用于语法快速筛选
    /// </summary>
    protected override string AttributeShortNameWithoutSuffix => "Log";


    /// <summary>
    ///     对类进行额外语义校验（可选）
    /// </summary>
    protected override bool ValidateSymbol(
        SourceProductionContext context,
        Compilation compilation,
        ClassDeclarationSyntax syntax,
        INamedTypeSymbol symbol,
        AttributeData attr)
    {
        // 可以加自定义规则，比如确保类是 public 或实现某接口
        return true;
    }

    /// <summary>
    ///     生成源代码
    /// </summary>
    /// <param name="context">源生产上下文</param>
    /// <param name="compilation">编译对象</param>
    /// <param name="symbol">命名类型符号</param>
    /// <param name="attr">属性数据</param>
    /// <returns>生成的源代码字符串</returns>
    protected override string Generate(
        SourceProductionContext context,
        Compilation compilation,
        INamedTypeSymbol symbol,
        AttributeData attr)
    {
        var ns = symbol.ContainingNamespace.IsGlobalNamespace
            ? null
            : symbol.ContainingNamespace.ToDisplayString();

        // 类名和嵌套类完整路径
        var className = symbol.GetFullClassName();

        // 构造函数参数解析
        var logName = className;
        if (attr.ConstructorArguments.Length > 0)
        {
            var argValue = attr.ConstructorArguments[0].Value;
            logName = argValue is string s && !string.IsNullOrWhiteSpace(s)
                ? s
                : className;
        }

        // 命名参数解析
        var fieldName = GetNamedArg(attr, "FieldName")?.ToString() ?? "_log";
        var access = GetNamedArg(attr, "AccessModifier")?.ToString() ?? "private";
        var isStaticObj = GetNamedArg(attr, "IsStatic");
        var isStatic = isStaticObj is not bool b || b; // 默认 true
        var staticKeyword = isStatic ? "static " : "";

        // 泛型参数
        var typeParams = symbol.TypeParameters.Length > 0
            ? "<" + string.Join(", ", symbol.TypeParameters.Select(tp => tp.Name)) + ">"
            : "";

        // 泛型约束
        var constraints = symbol.TypeParameters
            .Where(tp => tp.ConstraintTypes.Length > 0 || tp.HasReferenceTypeConstraint || tp.HasValueTypeConstraint ||
                         tp.HasConstructorConstraint)
            .Select(tp =>
            {
                var parts = new List<string>();

                if (tp.HasReferenceTypeConstraint) parts.Add("class");
                if (tp.HasValueTypeConstraint) parts.Add("struct");
                parts.AddRange(tp.ConstraintTypes.Select(t => t.ToDisplayString()));
                if (tp.HasConstructorConstraint) parts.Add("new()");

                return $"where {tp.Name} : {string.Join(", ", parts)}";
            });

        // 判断类型
        var typeKind = symbol.TypeKind switch
        {
            TypeKind.Class => "class",
            TypeKind.Struct => "struct",
#if NET5_0_OR_GREATER || ROSLYN_3_7_OR_GREATER
            TypeKind.Record => "record",
#endif
            _ => "class"
        };

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine($"using {PathContests.CoreAbstractionsNamespace}.logging;");
        sb.AppendLine($"using {PathContests.CoreNamespace}.logging;");

        if (ns is not null)
        {
            sb.AppendLine($"namespace {ns};");
            sb.AppendLine();
        }

        // 生成 partial 类
        sb.AppendLine($"partial {typeKind} {className}{typeParams}");
        foreach (var c in constraints)
            sb.AppendLine($"    {c}");
        sb.AppendLine("{");
        sb.AppendLine($"    /// <summary>Auto-generated logger</summary>");
        sb.AppendLine(
            $"    {access} {staticKeyword}readonly ILogger {fieldName} = LoggerFactoryResolver.Provider.CreateLogger(\"{logName}\");");
        sb.AppendLine("}");

        return sb.ToString().TrimEnd();
    }


    /// <summary>
    ///     可以自定义生成文件名
    /// </summary>
    protected override string GetHintName(INamedTypeSymbol symbol)
    {
        return $"{symbol.Name}.Logger.g.cs";
    }

    private static object? GetNamedArg(AttributeData attr, string name)
    {
        return attr.NamedArguments.FirstOrDefault(kv => kv.Key == name).Value.Value;
    }
}