using System.Linq;
using System.Text;
using GFramework.Core.Abstractions.rule;
using GFramework.SourceGenerators.Common.constants;
using GFramework.SourceGenerators.Common.generator;
using GFramework.SourceGenerators.diagnostics;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace GFramework.SourceGenerators.rule;

[Generator]
public sealed class ContextAwareGenerator : MetadataAttributeClassGeneratorBase
{
    /// <summary>
    /// 获取属性元数据的完整名称，用于标识ContextAwareAttribute的完全限定名
    /// </summary>
    /// <returns>返回ContextAwareAttribute的完全限定名字符串</returns>
    protected override string AttributeMetadataName =>
        $"{PathContests.SourceGeneratorsAbstractionsPath}.rule.ContextAwareAttribute";

    /// <summary>
    ///     仅用于 Syntax 粗筛选
    /// </summary>
    /// <returns>返回属性的简短名称，不包含后缀</returns>
    protected override string AttributeShortNameWithoutSuffix => "ContextAware";


    /// <summary>
    ///     额外语义校验：必须实现 IContextAware
    /// </summary>
    protected override bool ValidateSymbol(
        SourceProductionContext context,
        ClassDeclarationSyntax syntax,
        INamedTypeSymbol symbol,
        AttributeData attr)
    {
        if (symbol.AllInterfaces.Any(i =>
                i.ToDisplayString() == typeof(IContextAware).FullName)) return true;
        context.ReportDiagnostic(Diagnostic.Create(
            ContextAwareDiagnostic.ClassMustImplementIContextAware,
            syntax.Identifier.GetLocation(),
            symbol.Name));
        return false;
    }

    /// <summary>
    ///     生成源码
    /// </summary>
    protected override string Generate(
        INamedTypeSymbol symbol,
        AttributeData attr)
    {
        var ns = symbol.ContainingNamespace.IsGlobalNamespace
            ? null
            : symbol.ContainingNamespace.ToDisplayString();

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        if (ns is not null)
        {
            sb.AppendLine($"namespace {ns};");
            sb.AppendLine();
        }

        sb.AppendLine($"partial class {symbol.Name}");
        sb.AppendLine("{");

        // 属性
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// 自动注入的架构上下文");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine(
            $"    protected {PathContests.CoreAbstractionsNamespace}.architecture.IArchitectureContext Context {{ get; private set; }} = null!;");
        sb.AppendLine();

        // 方法
        sb.AppendLine(
            $"    void {PathContests.CoreAbstractionsNamespace}.rule.IContextAware.SetContext(");
        sb.AppendLine(
            $"        {PathContests.CoreAbstractionsNamespace}.architecture.IArchitectureContext context)");
        sb.AppendLine("    {");
        sb.AppendLine("        Context = context;");
        sb.AppendLine("    }");

        sb.AppendLine("}");

        return sb.ToString().TrimEnd();
    }


    /// <summary>
    ///     自定义生成文件名
    /// </summary>
    protected override string GetHintName(INamedTypeSymbol symbol)
    {
        // 包含命名空间和生成器类名路径
        return
            $"{symbol.Name}.ContextAware.g.cs";
    }
}