# GFramework.SourceGenerators API å‚è€ƒ

> GFramework.SourceGenerators æ¨¡å—çš„å®Œæ•´ API å‚è€ƒæ–‡æ¡£ï¼ŒåŒ…å«æ‰€æœ‰æºä»£ç ç”Ÿæˆå™¨çš„è¯¦ç»†è¯´æ˜ã€‚

## ğŸ“‹ ç›®å½•

- [æ—¥å¿—ç”Ÿæˆå™¨](#æ—¥å¿—ç”Ÿæˆå™¨)
- [ä¸Šä¸‹æ–‡æ„ŸçŸ¥ç”Ÿæˆå™¨](#ä¸Šä¸‹æ–‡æ„ŸçŸ¥ç”Ÿæˆå™¨)
- [æšä¸¾æ‰©å±•ç”Ÿæˆå™¨](#æšä¸¾æ‰©å±•ç”Ÿæˆå™¨)
- [è¯Šæ–­ç³»ç»Ÿ](#è¯Šæ–­ç³»ç»Ÿ)
- [é€šç”¨å·¥å…·](#é€šç”¨å·¥å…·)

## æ—¥å¿—ç”Ÿæˆå™¨

### [Log] å±æ€§

ä¸ºæ ‡è®°çš„ç±»è‡ªåŠ¨ç”Ÿæˆ ILogger å­—æ®µã€‚

#### æ„é€ å‡½æ•°å‚æ•°

```csharp
[Log(
    string fieldName = "Logger",              // ç”Ÿæˆçš„å­—æ®µå
    AccessModifier accessModifier = AccessModifier.Private, // è®¿é—®ä¿®é¥°ç¬¦
    bool isStatic = true,                   // æ˜¯å¦ç”Ÿæˆé™æ€å­—æ®µ
    string loggerName = null,                // è‡ªå®šä¹‰æ—¥å¿—å™¨åç§°
    LogLevel minLevel = LogLevel.None,          // æœ€å°æ—¥å¿—çº§åˆ«
    bool includeLoggerInterface = false       // æ˜¯å¦åŒ…å« ILogger æ¥å£
    bool enableConditionalCompilation = false  // æ˜¯å¦å¯ç”¨æ¡ä»¶ç¼–è¯‘
    string loggerInterfaceName = "ILogger"      // æ—¥å¿—æ¥å£åç§°
    bool suppressAutoGeneratedAttribute = false // æ˜¯å¦æŠ‘åˆ¶è‡ªåŠ¨ç”Ÿæˆå±æ€§
    string category = null                     // æ—¥å¿—ç±»åˆ«
    bool forceContextualLogging = false        // æ˜¯å¦å¼ºåˆ¶ä¸Šä¸‹æ–‡æ—¥å¿—
    bool enableStructuredLogging = false       // æ˜¯å¦å¯ç”¨ç»“æ„åŒ–æ—¥å¿—
    string loggerFactoryName = null           // æ—¥å¿—å·¥å‚åç§°
    string logMessagePrefix = null            // æ—¥å¿—æ¶ˆæ¯å‰ç¼€
    bool enablePerformanceLogging = false       // æ˜¯å¦å¯ç”¨æ€§èƒ½æ—¥å¿—
    bool enableAsyncLogging = false           // æ˜¯å¦å¯ç”¨å¼‚æ­¥æ—¥å¿—
    bool enableFluentLogging = false         // æ˜¯å¦å¯ç”¨æµç•…æ—¥å¿—
    bool enableScopedLogging = false           // æ˜¯å¦å¯ç”¨ä½œç”¨åŸŸæ—¥å¿—
)]
```

#### ç”Ÿæˆçš„ä»£ç ç¤ºä¾‹

```csharp
// é»˜è®¤é…ç½®ç”Ÿæˆçš„ä»£ç 
public partial class MyClass
{
    private static readonly ILogger Logger = 
        LoggerFactory.Create(builder => builder
            .AddConsole()
            .SetMinimumLevel(LogLevel.Information)
            .CreateLogger<MyClass>());
}

// è‡ªå®šä¹‰é…ç½®ç”Ÿæˆçš„ä»£ç 
[Log(
    fieldName = "CustomLogger",
    accessModifier = AccessModifier.Public,
    isStatic = false,
    loggerName = "Custom.MyClass",
    minLevel = LogLevel.Debug,
    includeLoggerInterface = true
)]
public partial class CustomClass : ILogger
{
    public ILogger CustomLogger { get; }
    
    static CustomClass()
    {
        CustomLogger = LoggerFactory.Create(builder => builder
            .AddConsole()
            .SetMinimumLevel(LogLevel.Debug)
            .CreateLogger<CustomClass>());
    }
}
```

#### æ”¯æŒçš„æ–¹æ³•

ç”Ÿæˆçš„ Logger æ”¯æŒä»¥ä¸‹æ–¹æ³•ï¼š

```csharp
// åŸºç¡€æ—¥å¿—æ–¹æ³•
Logger.LogDebug("Debug message");
Logger.LogInformation("Info message");
Logger.LogWarning("Warning message");
Logger.LogError("Error message");
Logger.LogCritical("Critical message");

// å¸¦æ ¼å¼åŒ–çš„æ—¥å¿—æ–¹æ³•
Logger.LogInformation("Player {Name} has {Health} health", playerName, playerHealth);

// å¼‚æ­¥æ—¥å¿—æ–¹æ³•
await Logger.LogInformationAsync("Async message");

// ç»“æ„åŒ–æ—¥å¿—
Logger.LogInformation(new { PlayerName = "John", Health = 100 }, "Player {Name} has {Health} health");
```

## ä¸Šä¸‹æ–‡æ„ŸçŸ¥ç”Ÿæˆå™¨

### [ContextAware] å±æ€§

ä¸ºæ ‡è®°çš„ç±»è‡ªåŠ¨å®ç° IContextAware æ¥å£ã€‚

#### ç”Ÿæˆçš„ä»£ç ç¤ºä¾‹

```csharp
[ContextAware]
public partial class MyClass : IContextAware
{
    private IContextAware.Context _context;
    
    public IContextAware.Context Context => _context ??= new LazyContext(this);
    
    public void SetContext(IContextAware.Context context)
    {
        _context = context;
    }
    
    public IContextAware.Context GetContext()
    {
        return _context;
    }
}

// ä½¿ç”¨å»¶è¿Ÿåˆå§‹åŒ–
[ContextAware(useLazy = true)]
public partial class LazyContextClass : IContextAware
{
    private Lazy<IContextAware.Context> _context;
    
    public IContextAware.Context Context => _context.Value;
    
    public void SetContext(IContextAware.Context context)
    {
        _context = new Lazy<IContextAware.Context>(() => context);
    }
}

// å¸¦ä¸Šä¸‹æ–‡éªŒè¯
[ContextAware(validateContext = true)]
public partial class ValidatedContextClass : IContextAware
{
    private IContextAware.Context _context;
    
    public IContextAware.Context Context => 
    {
        get => _context;
        private set
        {
            _context = value;
            if (_context?.IsInvalid == true)
            {
                throw new InvalidOperationException("Context is invalid");
            }
        }
    }
}
```

#### å¯ç”¨çš„æ–¹æ³•

```csharp
// è·å–æ¨¡å‹
var playerModel = Context.GetModel<PlayerModel>();
var gameModel = Context.GetModel<GameModel>();

// è·å–ç³»ç»Ÿ
var combatSystem = Context.GetSystem<CombatSystem>();
var audioSystem = Context.GetSystem<AudioSystem>();

// è·å–å·¥å…·
var storageUtility = Context.GetUtility<StorageUtility>();
var mathUtility = Context.GetUtility<MathUtility>();

// å‘é€äº‹ä»¶
Context.SendEvent<PlayerDiedEvent>();
Context.SendEvent<DamageDealtEvent>(new DamageDealtEvent { Damage = 50 });

// å‘é€å‘½ä»¤
Context.SendCommand(new AttackCommand());
var result = Context.SendCommand<AttackResult>(new AttackCommand());

// å‘é€æŸ¥è¯¢
var canAttack = Context.SendQuery<CanAttackQuery>();
var playerData = Context.SendQuery<GetPlayerDataQuery>();
```

## æšä¸¾æ‰©å±•ç”Ÿæˆå™¨

### [GenerateEnumExtensions] å±æ€§

ä¸ºæšä¸¾ç±»å‹è‡ªåŠ¨ç”Ÿæˆæ‰©å±•æ–¹æ³•ã€‚

#### æ„é€ å‡½æ•°å‚æ•°

```csharp
[GenerateEnumExtensions(
    bool generateIsMethods = true,         // æ˜¯å¦ç”Ÿæˆ IsX() æ–¹æ³•
    bool generateHasMethod = true,          // æ˜¯å¦ç”Ÿæˆ HasX() æ–¹æ³•
    bool generateInMethod = true,           // æ˜¯å¦ç”Ÿæˆ In(params T[]) æ–¹æ³•
    bool generateTryParseMethod = false,     // æ˜¯å¦ç”Ÿæˆ TryParse() æ–¹æ³•
    string customPrefix = "Is",              // è‡ªå®šä¹‰æ–¹æ³•åå‰ç¼€
    bool includeToString = false,           // æ˜¯å¦ç”Ÿæˆ ToString æ‰©å±•
    bool generateAllMethod = false,         // æ˜¯å¦ç”Ÿæˆ All() æ–¹æ³•
    bool generateCountMethod = false,       // æ˜¯å¦ç”Ÿæˆ Count() æ–¹æ³•
    bool generateDescriptionMethod = false,  // æ˜¯å¦ç”Ÿæˆ Description() æ–¹æ³•
    bool generateValuesMethod = false,       // æ˜¯å¦ç”Ÿæˆ Values() æ–¹æ³•
    string customNamespace = null,          // è‡ªå®šä¹‰å‘½åç©ºé—´
    bool generateExtensionMethods = true,    // æ˜¯å¦ç”Ÿæˆæ‰©å±•æ–¹æ³•
    bool generateFlagMethods = true,        // æ˜¯å¦ä¸ºä½æ ‡å¿—æšä¸¾ç”Ÿæˆæ–¹æ³•
    bool generateValidationMethods = false,  // æ˜¯å¦ç”ŸæˆéªŒè¯æ–¹æ³•
    bool generateUtilityMethods = false,    // æ˜¯å¦ç”Ÿæˆå·¥å…·æ–¹æ³•
    bool generateQueryableMethods = false,  // æ˜¯å¦ç”ŸæˆæŸ¥è¯¢æ–¹æ³•
    string customMethodNameFormat = null,     // è‡ªå®šä¹‰æ–¹æ³•åæ ¼å¼
    bool generateDocumentation = false,      // æ˜¯å¦ç”Ÿæˆæ–‡æ¡£æ³¨é‡Š
    bool generateExamples = false,          // æ˜¯å¦ç”Ÿæˆä½¿ç”¨ç¤ºä¾‹
)]
```

#### æ™®é€šæšä¸¾ç”Ÿæˆçš„ä»£ç ç¤ºä¾‹

```csharp
[GenerateEnumExtensions]
public enum PlayerState
{
    Idle,
    Walking,
    Running,
    Jumping,
    Attacking
}

// ç”Ÿæˆçš„æ‰©å±•æ–¹æ³•
public static class PlayerStateExtensions
{
    public static bool IsIdle(this PlayerState state) => state == PlayerState.Idle;
    public static bool IsWalking(this PlayerState state) => state == PlayerState.Walking;
    public static bool IsRunning(this PlayerState state) => state == PlayerState.Running;
    public static bool IsJumping(this PlayerState state) => state == PlayerState.Jumping;
    public static bool IsAttacking(this PlayerState state) => state == PlayerState.Attacking;
    
    public static bool In(this PlayerState state, params PlayerState[] values)
    {
        return values.Contains(state);
    }
}
```

#### ä½æ ‡å¿—æšä¸¾ç”Ÿæˆçš„ä»£ç ç¤ºä¾‹

```csharp
[GenerateEnumExtensions]
[Flags]
public enum PlayerPermissions
{
    None = 0,
    CanMove = 1 << 0,
    CanAttack = 1 << 1,
    CanUseItems = 1 << 2,
    CanChat = 1 << 3,
    CanTrade = 1 << 4
}

// ç”Ÿæˆçš„æ‰©å±•æ–¹æ³•
public static class PlayerPermissionsExtensions
{
    public static bool HasCanMove(this PlayerPermissions permissions) => permissions.HasFlag(PlayerPermissions.CanMove);
    public static bool HasCanAttack(this PlayerPermissions permissions) => permissions.HasFlag(PlayerPermissions.CanAttack);
    public static bool HasCanUseItems(this PlayerPermissions permissions) => permissions.HasFlag(PlayerPermissions.CanUseItems);
    
    public static bool HasAny(this PlayerPermissions permissions, params PlayerPermissions[] flags)
    {
        return flags.Any(flag => permissions.HasFlag(flag));
    }
    
    public static bool HasAll(this PlayerPermissions permissions, params PlayerPermissions[] flags)
    {
        return flags.All(flag => permissions.HasFlag(flag));
    }
    
    public static PlayerPermissions Add(this PlayerPermissions permissions, PlayerPermissions other)
    {
        return permissions | other;
    }
    
    public static PlayerPermissions Remove(this PlayerPermissions permissions, PlayerPermissions other)
    {
        return permissions & ~other;
    }
    
    public static PlayerPermissions Toggle(this PlayerPermissions permissions, PlayerPermissions flag)
    {
        return permissions ^ flag;
    }
}
```

#### é«˜çº§åŠŸèƒ½ç¤ºä¾‹

```csharp
[GenerateEnumExtensions(
    customPrefix = "Is",
    includeToString = true,
    generateDescriptionMethod = true,
    generateUtilityMethods = true
)]
public enum GameState
{
    [Description("æ¸¸æˆèœå•çŠ¶æ€")]
    Menu,
    
    [Description("æ¸¸æˆè¿›è¡Œä¸­")]
    Playing,
    
    [Description("æ¸¸æˆæš‚åœ")]
    Paused,
    
    [Description("æ¸¸æˆç»“æŸ")]
    GameOver
}

// ç”Ÿæˆçš„æ‰©å±•æ–¹æ³•åŒ…å«æ›´å¤šåŠŸèƒ½
public static class GameStateExtensions
{
    // IsX() æ–¹æ³•
    public static bool IsMenu(this GameState state) => state == GameState.Menu;
    public static bool IsPlaying(this GameState state) => state == GameState.Playing;
    public static bool IsPaused(this GameState state) => state == GameState.Paused;
    public static bool IsGameOver(this GameState state) => state == GameState.GameOver;
    
    // ToString() æ‰©å±•
    public static string ToDisplayString(this GameState state)
    {
        return state switch
        {
            GameState.Menu => "æ¸¸æˆèœå•",
            GameState.Playing => "æ¸¸æˆè¿›è¡Œä¸­",
            GameState.Paused => "æ¸¸æˆæš‚åœ",
            GameState.GameOver => "æ¸¸æˆç»“æŸ"
        };
    }
    
    // Description() æ‰©å±•
    public static string GetDescription(this GameState state)
    {
        return typeof(GameState)
            .GetMember(state.ToString())
            ?.GetCustomAttribute<DescriptionAttribute>()
            ?.Description ?? state.ToString();
    }
    
    // å·¥å…·æ–¹æ³•
    public static bool IsFinalState(this GameState state) => state == GameState.GameOver;
    public static bool IsPlayingState(this GameState state) => state == GameState.Playing;
    public static bool CanPause(this GameState state) => state == GameState.Playing;
    
    // éªŒè¯æ–¹æ³•
    public static bool IsValidTransition(this GameState from, GameState to)
    {
        return (from, to) switch
        {
            (GameState.Menu, GameState.Playing) => true,
            (GameState.Playing, GameState.Paused) => true,
            (GameState.Paused, GameState.Playing) => true,
            (GameState.Playing, GameState.GameOver) => true,
            _ => false
        };
    }
}
```

## è¯Šæ–­ç³»ç»Ÿ

### GF_Logging_001 - æ—¥å¿—å­—æ®µåå†²çª

å½“ä½¿ç”¨ `[Log]` å±æ€§æ—¶ï¼Œå¦‚æœå·²å­˜åœ¨åŒåå­—æ®µæˆ–å±æ€§ï¼Œä¼šè§¦å‘æ­¤è¯Šæ–­ã€‚

#### ç¤ºä¾‹

```csharp
// é”™è¯¯ç¤ºä¾‹ï¼šå­—æ®µåå†²çª
[Log(fieldName = "Logger")]
public partial class MyClass
{
    private readonly ILogger Logger; // âŒ å†²çªï¼
}

// æ­£ç¡®çš„è§£å†³æ–¹æ¡ˆ
[Log(fieldName = "CustomLogger")]
public partial class MyClass
{
    private readonly ILogger CustomLogger; // âœ… ä½¿ç”¨ä¸åŒçš„å­—æ®µå
}
```

#### è¯Šæ–­æ¶ˆæ¯

```
error GF_Logging_001: Logger field name 'Logger' conflicts with existing field in type 'MyClass'
```

### GF_Rule_001 - ä¸Šä¸‹æ–‡æ„ŸçŸ¥æ¥å£å†²çª

å½“ä½¿ç”¨ `[ContextAware]` å±æ€§æ—¶ï¼Œå¦‚æœç±»å‹å·²ç»å®ç°äº† IContextAware æ¥å£ï¼Œä¼šè§¦å‘æ­¤è¯Šæ–­ã€‚

#### ç¤ºä¾‹

```csharp
// é”™è¯¯ç¤ºä¾‹ï¼šæ¥å£å†²çª
[ContextAware]
public partial class MyClass : IContextAware // âŒ å†²çªï¼
{
    public IContextAware.Context Context { get; set; }
    public void SetContext(IContextAware.Context context) { }
    public IContextAware.Context GetContext() { return Context; }
}

// æ­£ç¡®çš„è§£å†³æ–¹æ¡ˆï¼šç§»é™¤æ‰‹åŠ¨å®ç°
[ContextAware]
public partial class MyClass // âœ… è®©ç”Ÿæˆå™¨å®ç°æ¥å£
{
    // ç§»é™¤æ‰‹åŠ¨å®ç°çš„ä»£ç 
}
```

#### è¯Šæ–­æ¶ˆæ¯

```
error GF_Rule_001: Type 'MyClass' already implements 'IContextAware' interface. Remove the [ContextAware] attribute or manual implementation.
```

## é€šç”¨å·¥å…·

### TypeHelper

ç±»å‹æ“ä½œçš„å·¥å…·ç±»ã€‚

#### ä¸»è¦æ–¹æ³•

```csharp
public static class TypeHelper
{
    // ç±»å‹æ£€æŸ¥
    public static bool IsNullable(Type type);
    public static bool IsGenericType(Type type);
    public static bool IsValueType(Type type);
    public static bool IsEnum(Type type);
    
    // æ³›å‹ç±»å‹ä¿¡æ¯
    public static Type GetGenericTypeDefinition(Type type);
    public static Type[] GetGenericArguments(Type type);
    public static bool ImplementsInterface(Type type, Type interfaceType);
    
    // å±æ€§ä¿¡æ¯
    public static PropertyInfo[] GetProperties(Type type, BindingFlags flags = BindingFlags.Public | BindingFlags.Instance);
    public static PropertyInfo GetProperty(Type type, string name, BindingFlags flags = BindingFlags.Public | BindingFlags.Instance);
    public static bool HasProperty(Type type, string name);
    
    // æ–¹æ³•ä¿¡æ¯
    public static MethodInfo[] GetMethods(Type type, BindingFlags flags = BindingFlags.Public | BindingFlags.Instance);
    public static MethodInfo GetMethod(Type type, string name, BindingFlags flags = BindingFlags.Public | BindingFlags.Instance);
    public static bool HasMethod(Type type, string name);
    
    // æ„é€ å‡½æ•°ä¿¡æ¯
    public static ConstructorInfo[] GetConstructors(Type type, BindingFlags flags = BindingFlags.Public | BindingFlags.Instance);
    public static ConstructorInfo GetConstructor(Type type, Type[] parameterTypes);
    
    // å¯å®ä¾‹åŒ–æ£€æŸ¥
    public static bool HasParameterlessConstructor(Type type);
    public static bool HasConstructor(Type type, params Type[] parameterTypes);
}
```

### SymbolHelper

ç¬¦å·æ“ä½œçš„å·¥å…·ç±»ã€‚

#### ä¸»è¦æ–¹æ³•

```csharp
public static class SymbolHelper
{
    // è·å–ç¬¦å·ä¿¡æ¯
    public static ITypeSymbol GetSymbolInfo(INamedTypeSymbol symbol, Compilation compilation);
    public static IMethodSymbol GetMethodInfo(IMethodSymbol symbol);
    public static IPropertySymbol GetPropertyInfo(IPropertySymbol symbol);
    public static IEventSymbol GetEventInfo(IEventSymbol symbol);
    
    // ç¬¦å·æ¯”è¾ƒ
    public static bool IsSameSymbol(ISymbol symbol1, ISymbol symbol2);
    public static string GetFullyQualifiedName(ISymbol symbol);
    public static string GetDocumentationCommentXml(ISymbol symbol);
    
    // ç¬¦å·æŸ¥æ‰¾
    public static IEnumerable<ISymbol> GetMembers(INamedTypeSymbol symbol);
    public static ISymbol GetMember(INamedTypeSymbol symbol, string name);
    public static IEnumerable<AttributeData> GetAttributes(ISymbol symbol);
    public static T GetAttribute<T>(ISymbol symbol);
    public static bool HasAttribute<T>(ISymbol symbol);
}
```

### CompilationHelper

ç¼–è¯‘æ“ä½œçš„å·¥å…·ç±»ã€‚

#### ä¸»è¦æ–¹æ³•

```csharp
public static class CompilationHelper
{
    // è·å–ç¼–è¯‘
    public static Compilation GetCompilation(Compilation startingCompilation);
    public static Compilation GetCompilation(SyntaxTree syntaxTree);
    public static Compilation GetCompilation(IEnumerable<SyntaxTree> syntaxTrees);
    
    // è·å–è¯­ä¹‰æ¨¡å‹
    public static SemanticModel GetSemanticModel(Compilation compilation);
    public static SemanticModel GetSemanticModel(SyntaxTree syntaxTree);
    
    // ç¬¦å·æŸ¥æ‰¾
    public static INamedTypeSymbol GetDeclaredTypeSymbol(Compilation compilation, string name);
    public static IMethodSymbol GetDeclaredMethodSymbol(Compilation compilation, string name);
    public static IPropertySymbol GetDeclaredPropertySymbol(Compilation compilation, string name);
    
    // ç±»å‹è§£æ
    public static INamedTypeSymbol ResolveType(Compilation compilation, string metadataName);
    public static ITypeSymbol ResolveType(Compilation compilation, Type type);
    public static IMethodSymbol ResolveMethod(Compilation compilation, string methodFullName, params ITypeSymbol[] parameterTypes);
    
    // ç¼–è¯‘æ£€æŸ¥
    public static bool HasCompilationErrors(Compilation compilation);
    public static IEnumerable<Diagnostic> GetCompilationDiagnostics(Compilation compilation);
    public static string GetCompilationErrors(Compilation compilation);
}
```

---

## é…ç½®ç¤ºä¾‹

### é¡¹ç›®æ–‡ä»¶é…ç½®

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net6.0</TargetFramework>
    <Nullable>enable</Nullable>
    <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>
    <CompilerGeneratedFilesOutputPath>Generated</CompilerGeneratedFilesOutputPath>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="GeWuYou.GFramework.SourceGenerators" Version="1.0.0" />
    <PackageReference Include="GeWuYou.GFramework.SourceGenerators.Attributes" Version="1.0.0" />
  </ItemGroup>

  <ItemGroup>
    <Compile Remove="$(CompilerGeneratedFilesOutputPath)/**/*.cs" />
  </ItemGroup>
</Project>
```

### ç¼–è¾‘å™¨é…ç½®

```json
{
    "sourceGenerators": {
        "debug": true,
        "logLevel": "Information",
        "outputDirectory": "Generated",
        "enableDocumentation": true,
        "enablePerformanceLogging": false
    },
    "loggingGenerator": {
        "defaultFieldName": "Logger",
        "defaultAccessLevel": "Private",
        "defaultStatic": true,
        "defaultMinLevel": "None"
    },
    "contextAwareGenerator": {
        "useLazyInit": false,
        "validateContext": false
    },
    "enumExtensionsGenerator": {
        "generateIsMethods": true,
        "generateHasMethod": true,
        "generateInMethod": true,
        "customPrefix": "Is"
    }
}
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0.0  
**æ›´æ–°æ—¥æœŸ**: 2026-01-12