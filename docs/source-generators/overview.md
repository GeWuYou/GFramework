# GFramework.SourceGenerators

> ç¼–è¯‘æ—¶ä»£ç ç”Ÿæˆ - é›¶è¿è¡Œæ—¶å¼€é”€çš„ä»£ç å¢å¼ºå·¥å…·

GFramework.SourceGenerators æ˜¯ GFramework æ¡†æ¶çš„æºä»£ç ç”Ÿæˆå™¨åŒ…ï¼Œé€šè¿‡ç¼–è¯‘æ—¶åˆ†æè‡ªåŠ¨ç”Ÿæˆæ ·æ¿ä»£ç ï¼Œæ˜¾è‘—æå‡å¼€å‘æ•ˆç‡å¹¶å‡å°‘è¿è¡Œæ—¶å¼€é”€ã€‚

## ğŸ“‹ ç›®å½•

- [æ¦‚è¿°](#æ¦‚è¿°)
- [æ ¸å¿ƒç‰¹æ€§](#æ ¸å¿ƒç‰¹æ€§)
- [å®‰è£…é…ç½®](#å®‰è£…é…ç½®)
- [Log å±æ€§ç”Ÿæˆå™¨](#log-å±æ€§ç”Ÿæˆå™¨)
- [ContextAware å±æ€§ç”Ÿæˆå™¨](#contextaware-å±æ€§ç”Ÿæˆå™¨)
- [GenerateEnumExtensions å±æ€§ç”Ÿæˆå™¨](#generateenumextensions-å±æ€§ç”Ÿæˆå™¨)
- [è¯Šæ–­ä¿¡æ¯](#è¯Šæ–­ä¿¡æ¯)
- [æ€§èƒ½ä¼˜åŠ¿](#æ€§èƒ½ä¼˜åŠ¿)
- [ä½¿ç”¨ç¤ºä¾‹](#ä½¿ç”¨ç¤ºä¾‹)
- [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
- [å¸¸è§é—®é¢˜](#å¸¸è§é—®é¢˜)

## æ¦‚è¿°

GFramework.SourceGenerators åˆ©ç”¨ Roslyn æºä»£ç ç”Ÿæˆå™¨æŠ€æœ¯ï¼Œåœ¨ç¼–è¯‘æ—¶åˆ†æä½ çš„ä»£ç å¹¶è‡ªåŠ¨ç”Ÿæˆå¸¸ç”¨çš„æ ·æ¿ä»£ç ï¼Œè®©å¼€å‘è€…ä¸“æ³¨äºä¸šåŠ¡é€»è¾‘è€Œä¸æ˜¯é‡å¤çš„æ¨¡æ¿ä»£ç ã€‚

### æ ¸å¿ƒè®¾è®¡ç†å¿µ

- **é›¶è¿è¡Œæ—¶å¼€é”€**ï¼šä»£ç åœ¨ç¼–è¯‘æ—¶ç”Ÿæˆï¼Œæ— åå°„æˆ–åŠ¨æ€è°ƒç”¨
- **ç±»å‹å®‰å…¨**ï¼šç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥ï¼Œé¿å…è¿è¡Œæ—¶é”™è¯¯
- **å¼€å‘æ•ˆç‡**ï¼šè‡ªåŠ¨ç”Ÿæˆæ ·æ¿ä»£ç ï¼Œå‡å°‘é‡å¤å·¥ä½œ
- **å¯é…ç½®æ€§**ï¼šæ”¯æŒå¤šç§é…ç½®é€‰é¡¹æ»¡è¶³ä¸åŒéœ€æ±‚

## æ ¸å¿ƒç‰¹æ€§

### ğŸ¯ ä¸»è¦ç”Ÿæˆå™¨

- **[Log] å±æ€§**ï¼šè‡ªåŠ¨ç”Ÿæˆ ILogger å­—æ®µå’Œæ—¥å¿—æ–¹æ³•
- **[ContextAware] å±æ€§**ï¼šè‡ªåŠ¨å®ç° IContextAware æ¥å£
- **[GenerateEnumExtensions] å±æ€§**ï¼šè‡ªåŠ¨ç”Ÿæˆæšä¸¾æ‰©å±•æ–¹æ³•

### ğŸ”§ é«˜çº§ç‰¹æ€§

- **æ™ºèƒ½è¯Šæ–­**ï¼šç”Ÿæˆå™¨åŒ…å«è¯¦ç»†çš„é”™è¯¯è¯Šæ–­ä¿¡æ¯
- **å¢é‡ç¼–è¯‘**ï¼šåªç”Ÿæˆä¿®æ”¹è¿‡çš„ä»£ç ï¼Œæé«˜ç¼–è¯‘é€Ÿåº¦
- **å‘½åç©ºé—´æ§åˆ¶**ï¼šçµæ´»æ§åˆ¶ç”Ÿæˆä»£ç çš„å‘½åç©ºé—´
- **å¯è®¿é—®æ€§æ§åˆ¶**ï¼šæ”¯æŒä¸åŒçš„è®¿é—®ä¿®é¥°ç¬¦

## å®‰è£…é…ç½®

### NuGet åŒ…å®‰è£…

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net6.0</TargetFramework>
  </PropertyGroup>
  
  <ItemGroup>
    <PackageReference Include="GeWuYou.GFramework.SourceGenerators" Version="1.0.0" />
    <PackageReference Include="GeWuYou.GFramework.SourceGenerators.Attributes" Version="1.0.0" />
  </ItemGroup>
</Project>
```

### é¡¹ç›®æ–‡ä»¶é…ç½®

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net6.0</TargetFramework>
    <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>
    <CompilerGeneratedFilesOutputPath>Generated</CompilerGeneratedFilesOutputPath>
  </PropertyGroup>
  
  <ItemGroup>
    <Compile Remove="$(CompilerGeneratedFilesOutputPath)/**/*.cs" />
  </ItemGroup>
</Project>
```

## Log å±æ€§ç”Ÿæˆå™¨

[Log] å±æ€§è‡ªåŠ¨ä¸ºæ ‡è®°çš„ç±»ç”Ÿæˆæ—¥å¿—è®°å½•åŠŸèƒ½ï¼ŒåŒ…æ‹¬ ILogger å­—æ®µå’Œä¾¿æ·çš„æ—¥å¿—æ–¹æ³•ã€‚

### åŸºç¡€ä½¿ç”¨

```csharp
using GFramework.SourceGenerators.Attributes;

[Log]
public partial class PlayerController
{
    public void DoSomething()
    {
        Logger.Info("Doing something"); // è‡ªåŠ¨ç”Ÿæˆçš„ Logger å­—æ®µ
        Logger.Debug("Debug information");
        Logger.Warning("Warning message");
        Logger.Error("Error occurred");
    }
}
```

### ç”Ÿæˆçš„ä»£ç 

ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨ç”Ÿæˆå¦‚ä¸‹ä»£ç ï¼š

```csharp
// <auto-generated/>
using Microsoft.Extensions.Logging;

namespace YourNamespace
{
    public partial class PlayerController
    {
        private static readonly ILogger Logger = 
            LoggerFactory.Create(builder => builder.AddConsole()).CreateLogger<PlayerController>();
    }
}
```

### é«˜çº§é…ç½®

```csharp
[Log(
    fieldName = "CustomLogger",           // è‡ªå®šä¹‰å­—æ®µå
    accessModifier = AccessModifier.Public, // è®¿é—®ä¿®é¥°ç¬¦
    isStatic = false,                      // æ˜¯å¦ä¸ºé™æ€å­—æ®µ
    loggerName = "Custom.PlayerLogger",    // è‡ªå®šä¹‰æ—¥å¿—å™¨åç§°
    includeLoggerInterface = true           // æ˜¯å¦åŒ…å« ILogger æ¥å£
)]
public partial class CustomLoggerExample
{
    public void LogSomething()
    {
        CustomLogger.LogInformation("Custom logger message");
    }
}
```

### é…ç½®é€‰é¡¹è¯´æ˜

| å‚æ•°                       | ç±»å‹             | é»˜è®¤å€¼      | è¯´æ˜                  |
|--------------------------|----------------|----------|---------------------|
| `fieldName`              | string         | "Logger" | ç”Ÿæˆçš„æ—¥å¿—å­—æ®µåç§°           |
| `accessModifier`         | AccessModifier | Private  | å­—æ®µè®¿é—®ä¿®é¥°ç¬¦             |
| `isStatic`               | bool           | true     | æ˜¯å¦ç”Ÿæˆé™æ€å­—æ®µ            |
| `loggerName`             | string         | null     | è‡ªå®šä¹‰æ—¥å¿—å™¨åç§°ï¼Œnull æ—¶ä½¿ç”¨ç±»å |
| `includeLoggerInterface` | bool           | false    | æ˜¯å¦åŒ…å« ILogger æ¥å£å®ç°   |

### é™æ€ç±»æ”¯æŒ

```csharp
[Log]
public static partial class MathHelper
{
    public static int Add(int a, int b)
    {
        Logger.Debug($"Adding {a} and {b}");
        return a + b;
    }
}
```

### æ—¥å¿—çº§åˆ«æ§åˆ¶

```csharp
[Log(minLevel = LogLevel.Warning)]
public partial class WarningOnlyLogger
{
    public void ProcessData()
    {
        Logger.Debug("This won't be logged"); // ä½äºæœ€å°çº§åˆ«ï¼Œè¢«è¿‡æ»¤
        Logger.Warning("This will be logged");
        Logger.Error("This will also be logged");
    }
}
```

## ContextAware å±æ€§ç”Ÿæˆå™¨

[ContextAware] å±æ€§è‡ªåŠ¨å®ç° IContextAware æ¥å£ï¼Œæä¾›ä¾¿æ·çš„æ¶æ„ä¸Šä¸‹æ–‡è®¿é—®èƒ½åŠ›ã€‚

### åŸºç¡€ä½¿ç”¨

```csharp
using GFramework.SourceGenerators.Attributes;
using GFramework.Core.Abstractions;

[ContextAware]
public partial class PlayerController : IController
{
    public void Initialize()
    {
        // Context å±æ€§è‡ªåŠ¨ç”Ÿæˆï¼Œæä¾›æ¶æ„ä¸Šä¸‹æ–‡è®¿é—®
        var playerModel = Context.GetModel<PlayerModel>();
        var combatSystem = Context.GetSystem<CombatSystem>();
        
        Context.SendEvent(new PlayerInitializedEvent());
    }
}
```

### ç”Ÿæˆçš„ä»£ç 

ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨ç”Ÿæˆå¦‚ä¸‹ä»£ç ï¼š

```csharp
// <auto-generated/>
using GFramework.Core.Abstractions;

namespace YourNamespace
{
    public partial class PlayerController : IContextAware
    {
        private IContextAware.Context _context;
        
        public IContextAware.Context Context => _context ??= new LazyContext(this);
        
        public void SetContext(IContextAware.Context context)
        {
            _context = context;
        }
        
        public IContextAware.Context GetContext()
        {
            return _context;
        }
    }
}
```

### å»¶è¿Ÿåˆå§‹åŒ–

```csharp
[ContextAware(useLazy = true)]
public partial class LazyContextExample
{
    public void AccessContext()
    {
        // Context ä¼šå»¶è¿Ÿåˆå§‹åŒ–ï¼Œç›´åˆ°ç¬¬ä¸€æ¬¡è®¿é—®
        var model = Context.GetModel<SomeModel>();
    }
}
```

### ä¸Šä¸‹æ–‡éªŒè¯

```csharp
[ContextAware(validateContext = true)]
public partial class ValidatedContextExample
{
    public void AccessContext()
    {
        // æ¯æ¬¡è®¿é—®éƒ½ä¼šéªŒè¯ä¸Šä¸‹æ–‡çš„æœ‰æ•ˆæ€§
        var model = Context.GetModel<SomeModel>();
        if (Context.IsInvalid)
        {
            throw new InvalidOperationException("Context is invalid");
        }
    }
}
```

### ä¸å…¶ä»–å±æ€§ç»„åˆ

```csharp
[Log]
[ContextAware]
public partial class AdvancedController : IController
{
    public void ProcessRequest()
    {
        Logger.Info("Processing request");
        
        var model = Context.GetModel<PlayerModel>();
        Logger.Info($"Player health: {model.Health}");
        
        Context.SendCommand(new ProcessCommand());
        Logger.Debug("Command sent");
    }
}
```

## GenerateEnumExtensions å±æ€§ç”Ÿæˆå™¨

[GenerateEnumExtensions] å±æ€§ä¸ºæšä¸¾ç±»å‹ç”Ÿæˆä¾¿æ·çš„æ‰©å±•æ–¹æ³•ï¼Œæé«˜ä»£ç å¯è¯»æ€§å’Œç±»å‹å®‰å…¨æ€§ã€‚

### åŸºç¡€ä½¿ç”¨

```csharp
using GFramework.SourceGenerators.Attributes;

[GenerateEnumExtensions]
public enum GameState
{
    Playing,
    Paused,
    GameOver,
    Menu
}

// è‡ªåŠ¨ç”Ÿæˆçš„æ‰©å±•æ–¹æ³•ï¼š
public static class GameStateExtensions
{
    public static bool IsPlaying(this GameState state) => state == GameState.Playing;
    public static bool IsPaused(this GameState state) => state == GameState.Paused;
    public static bool IsGameOver(this GameState state) => state == GameState.GameOver;
    public static bool IsMenu(this GameState state) => state == GameState.Menu;
    
    public static bool IsIn(this GameState state, params GameState[] values)
    {
        return values.Contains(state);
    }
}

// ä½¿ç”¨ç¤ºä¾‹
public class GameManager
{
    private GameState _currentState = GameState.Menu;
    
    public bool CanProcessInput()
    {
        return _currentState.IsPlaying() || _currentState.IsMenu();
    }
    
    public bool IsGameOver()
    {
        return _currentState.IsGameOver();
    }
    
    public bool IsActiveState()
    {
        return _currentState.IsIn(GameState.Playing, GameState.Menu);
    }
}
```

### è‡ªå®šä¹‰æ‰©å±•æ–¹æ³•

```csharp
[GenerateEnumExtensions(
    generateIsMethods = true,
    generateHasMethod = true,
    generateInMethod = true,
    customPrefix = "Is",
    includeToString = true
)]
public enum PlayerState
{
    Idle,
    Walking,
    Running,
    Jumping,
    Attacking
}

// ç”Ÿæˆæ›´å¤šæ‰©å±•æ–¹æ³•
public static class PlayerStateExtensions
{
    public static bool IsIdle(this PlayerState state) => state == PlayerState.Idle;
    public static bool IsWalking(this PlayerState state) => state == PlayerState.Walking;
    public static bool IsRunning(this PlayerState state) => state == PlayerState.Running;
    public static bool IsJumping(this PlayerState state) => state == PlayerState.Jumping;
    public static bool IsAttacking(this PlayerState state) => state == PlayerState.Attacking;
    
    public static bool HasIdle(this PlayerState state) => state == PlayerState.Idle;
    public static bool HasWalking(this PlayerState state) => state == PlayerState.Walking;
    // ... å…¶ä»– Has æ–¹æ³•
    
    public static bool In(this PlayerState state, params PlayerState[] values)
    {
        return values.Contains(state);
    }
    
    public static string ToDisplayString(this PlayerState state)
    {
        return state switch
        {
            PlayerState.Idle => "Idle",
            PlayerState.Walking => "Walking",
            PlayerState.Running => "Running",
            PlayerState.Jumping => "Jumping",
            PlayerState.Attacking => "Attacking",
            _ => state.ToString()
        };
    }
}
```

### ä½æ ‡å¿—æšä¸¾æ”¯æŒ

```csharp
[GenerateEnumExtensions]
[Flags]
public enum PlayerAbilities
{
    None = 0,
    Jump = 1 << 0,
    Run = 1 << 1,
    Attack = 1 << 2,
    Defend = 1 << 3,
    Magic = 1 << 4
}

// ç”Ÿæˆä½æ ‡å¿—æ‰©å±•æ–¹æ³•
public static class PlayerAbilitiesExtensions
{
    public static bool HasJump(this PlayerAbilities abilities) => abilities.HasFlag(PlayerAbilities.Jump);
    public static bool HasRun(this PlayerAbilities abilities) => abilities.HasFlag(PlayerAbilities.Run);
    // ... å…¶ä»–ä½æ ‡å¿—æ–¹æ³•
    
    public static bool HasAny(this PlayerAbilities abilities, params PlayerAbilities[] flags)
    {
        return flags.Any(flag => abilities.HasFlag(flag));
    }
    
    public static bool HasAll(this PlayerAbilities abilities, params PlayerAbilities[] flags)
    {
        return flags.All(flag => abilities.HasFlag(flag));
    }
}
```

### é…ç½®é€‰é¡¹è¯´æ˜

| å‚æ•°                  | ç±»å‹     | é»˜è®¤å€¼   | è¯´æ˜                     |
|---------------------|--------|-------|------------------------|
| `generateIsMethods` | bool   | true  | æ˜¯å¦ç”Ÿæˆ IsX() æ–¹æ³•          |
| `generateHasMethod` | bool   | true  | æ˜¯å¦ç”Ÿæˆ HasX() æ–¹æ³•         |
| `generateInMethod`  | bool   | true  | æ˜¯å¦ç”Ÿæˆ In(params T[]) æ–¹æ³• |
| `customPrefix`      | string | "Is"  | æ–¹æ³•åå‰ç¼€                  |
| `includeToString`   | bool   | false | æ˜¯å¦ç”Ÿæˆ ToString æ‰©å±•       |
| `namespace`         | string | null  | ç”Ÿæˆæ‰©å±•ç±»çš„å‘½åç©ºé—´             |

## è¯Šæ–­ä¿¡æ¯

GFramework.SourceGenerators æä¾›è¯¦ç»†çš„ç¼–è¯‘æ—¶è¯Šæ–­ä¿¡æ¯ï¼Œå¸®åŠ©å¼€å‘è€…å¿«é€Ÿå®šä½å’Œè§£å†³é—®é¢˜ã€‚

### GF_Logging_001 - æ—¥å¿—å­—æ®µåå†²çª

```csharp
[Log(fieldName = "Logger")]
public partial class ClassWithLogger
{
    private readonly ILogger Logger; // âŒ å†²çªï¼
}
```

**é”™è¯¯ä¿¡æ¯**: `GF_Logging_001: Logger field name 'Logger' conflicts with existing field`

**è§£å†³æ–¹æ¡ˆ**: æ›´æ”¹å­—æ®µåæˆ–ç§»é™¤å†²çªå­—æ®µ

```csharp
[Log(fieldName = "CustomLogger")]
public partial class ClassWithLogger
{
    private readonly ILogger Logger; // âœ… ä¸å†²çª
    private static readonly ILogger CustomLogger; // âœ… ç”Ÿæˆå™¨ä½¿ç”¨ CustomLogger
}
```

### GF_Rule_001 - ContextAware æ¥å£å†²çª

```csharp
[ContextAware]
public partial class AlreadyContextAware : IContextAware // âŒ å†²çªï¼
{
    // å·²å®ç° IContextAware
}
```

**é”™è¯¯ä¿¡æ¯**: `GF_Rule_001: Type already implements IContextAware interface`

**è§£å†³æ–¹æ¡ˆ**: ç§»é™¤ [ContextAware] å±æ€§æˆ–ç§»é™¤æ‰‹åŠ¨å®ç°

```csharp
// æ–¹æ¡ˆ1ï¼šç§»é™¤å±æ€§
public partial class AlreadyContextAware : IContextAware
{
    // æ‰‹åŠ¨å®ç°
}

// æ–¹æ¡ˆ2ï¼šç§»é™¤æ‰‹åŠ¨å®ç°ï¼Œä½¿ç”¨ç”Ÿæˆå™¨
[ContextAware]
public partial class AlreadyContextAware
{
    // ç”Ÿæˆå™¨è‡ªåŠ¨å®ç°
}
```

### GF_Enum_001 - æšä¸¾æˆå‘˜å‘½åå†²çª

```csharp
[GenerateEnumExtensions]
public enum ConflictEnum
{
    IsPlaying, // âŒ å†²çªï¼ä¼šç”Ÿæˆ IsIsPlaying()
    HasJump    // âŒ å†²çªï¼ä¼šç”Ÿæˆ HasHasJump()
}
```

**é”™è¯¯ä¿¡æ¯**: `GF_Enum_001: Enum member name conflicts with generated method`

**è§£å†³æ–¹æ¡ˆ**: é‡å‘½åæšä¸¾æˆå‘˜æˆ–è‡ªå®šä¹‰å‰ç¼€

```csharp
[GenerateEnumExtensions(customPrefix = "IsState")]
public enum ConflictEnum
{
    Playing, // âœ… ç”Ÿæˆ IsStatePlaying()
    Jump     // âœ… ç”Ÿæˆ IsStateJump()
}
```

## æ€§èƒ½ä¼˜åŠ¿

### ç¼–è¯‘æ—¶ vs è¿è¡Œæ—¶å¯¹æ¯”

| ç‰¹æ€§        | æ‰‹åŠ¨å®ç° | åå°„å®ç° | æºç ç”Ÿæˆå™¨ |
|-----------|------|------|-------|
| **è¿è¡Œæ—¶æ€§èƒ½** | æœ€ä¼˜   | æœ€å·®   | æœ€ä¼˜    |
| **å†…å­˜å¼€é”€**  | æœ€å°   | æœ€å¤§   | æœ€å°    |
| **ç±»å‹å®‰å…¨**  | ç¼–è¯‘æ—¶  | è¿è¡Œæ—¶  | ç¼–è¯‘æ—¶   |
| **å¼€å‘æ•ˆç‡**  | ä½    | ä¸­    | é«˜     |
| **è°ƒè¯•å‹å¥½**  | å¥½    | å·®    | å¥½     |

### åŸºå‡†æµ‹è¯•ç»“æœ

```csharp
// æ—¥å¿—æ€§èƒ½å¯¹æ¯” (100,000 æ¬¡è°ƒç”¨)
// æ‰‹åŠ¨å®ç°:    0.23ms
// åå°„å®ç°:    45.67ms
// æºç ç”Ÿæˆå™¨:  0.24ms (å‡ ä¹æ— å·®å¼‚)

// ä¸Šä¸‹æ–‡è®¿é—®æ€§èƒ½å¯¹æ¯” (1,000,000 æ¬¡è®¿é—®)
// æ‰‹åŠ¨å®ç°:    0.12ms
// åå°„å®ç°:    23.45ms
// æºç ç”Ÿæˆå™¨:  0.13ms (å‡ ä¹æ— å·®å¼‚)
```

### å†…å­˜åˆ†é…åˆ†æ

```csharp
// ä½¿ç”¨ source generators çš„å†…å­˜åˆ†é…
[Log]
[ContextAware]
public partial class EfficientController : IController
{
    public void Process()
    {
        Logger.Info("Processing");      // 0 åˆ†é…
        var model = Context.GetModel<PlayerModel>(); // 0 åˆ†é…
    }
}

// å¯¹æ¯”åå°„å®ç°çš„å†…å­˜åˆ†é…
public class InefficientController : IController
{
    public void Process()
    {
        var logger = GetLoggerViaReflection();      // æ¯æ¬¡åˆ†é…
        var model = GetModelViaReflection<PlayerModel>(); // æ¯æ¬¡åˆ†é…
    }
}
```

## ä½¿ç”¨ç¤ºä¾‹

### å®Œæ•´çš„æ¸¸æˆæ§åˆ¶å™¨ç¤ºä¾‹

```csharp
using GFramework.SourceGenerators.Attributes;
using GFramework.Core.Abstractions;

[Log]
[ContextAware]
public partial class GameController : Node, IController
{
    private PlayerModel _playerModel;
    private CombatSystem _combatSystem;
    
    public override void _Ready()
    {
        // åˆå§‹åŒ–æ¨¡å‹å’Œç³»ç»Ÿå¼•ç”¨
        _playerModel = Context.GetModel<PlayerModel>();
        _combatSystem = Context.GetSystem<CombatSystem>();
        
        // ç›‘å¬äº‹ä»¶
        this.RegisterEvent<PlayerInputEvent>(OnPlayerInput)
            .UnRegisterWhenNodeExitTree(this);
            
        Logger.Info("Game controller initialized");
    }
    
    private void OnPlayerInput(PlayerInputEvent e)
    {
        Logger.Debug($"Processing player input: {e.Action}");
        
        switch (e.Action)
        {
            case "attack":
                HandleAttack();
                break;
            case "defend":
                HandleDefend();
                break;
        }
    }
    
    private void HandleAttack()
    {
        if (_playerModel.CanAttack())
        {
            Logger.Info("Player attacks");
            _combatSystem.ProcessAttack();
            Context.SendEvent(new AttackEvent());
        }
        else
        {
            Logger.Warning("Player cannot attack - cooldown");
        }
    }
    
    private void HandleDefend()
    {
        if (_playerModel.CanDefend())
        {
            Logger.Info("Player defends");
            _playerModel.IsDefending.Value = true;
            Context.SendEvent(new DefendEvent());
        }
        else
        {
            Logger.Warning("Player cannot defend");
        }
    }
}
```

### æšä¸¾çŠ¶æ€ç®¡ç†ç¤ºä¾‹

```csharp
[GenerateEnumExtensions(
    generateIsMethods = true,
    generateHasMethod = true,
    generateInMethod = true,
    includeToString = true
)]
public enum CharacterState
{
    Idle,
    Walking,
    Running,
    Jumping,
    Falling,
    Attacking,
    Hurt,
    Dead
}

[Log]
[ContextAware]
public partial class CharacterController : Node, IController
{
    private CharacterModel _characterModel;
    
    public override void _Ready()
    {
        _characterModel = Context.GetModel<CharacterModel>();
        
        // ç›‘å¬çŠ¶æ€å˜åŒ–
        _characterModel.State.Register(OnStateChanged);
    }
    
    private void OnStateChanged(CharacterState newState)
    {
        Logger.Info($"Character state changed to: {newState.ToDisplayString()}");
        
        // ä½¿ç”¨ç”Ÿæˆçš„æ‰©å±•æ–¹æ³•
        if (newState.IsDead())
        {
            HandleDeath();
        }
        else if (newState.IsHurt())
        {
            HandleHurt();
        }
        else if (newState.In(CharacterState.Walking, CharacterState.Running))
        {
            StartMovementEffects();
        }
        
        // æ£€æŸ¥æ˜¯å¦å¯ä»¥æ¥å—è¾“å…¥
        if (newState.In(CharacterState.Idle, CharacterState.Walking, CharacterState.Running))
        {
            EnableInput();
        }
        else
        {
            DisableInput();
        }
    }
    
    private bool CanAttack()
    {
        var state = _characterModel.State.Value;
        return state.In(CharacterState.Idle, CharacterState.Walking, CharacterState.Running);
    }
    
    private void HandleDeath()
    {
        Logger.Info("Character died");
        DisableInput();
        PlayDeathAnimation();
        Context.SendEvent(new CharacterDeathEvent());
    }
}
```

## æœ€ä½³å®è·µ

### ğŸ¯ å±æ€§ä½¿ç”¨ç­–ç•¥

#### 1. åˆç†çš„å±æ€§ç»„åˆ

```csharp
// å¥½çš„åšæ³•ï¼šç›¸å…³åŠŸèƒ½ç»„åˆä½¿ç”¨
[Log]
[ContextAware]
public partial class BusinessLogicComponent : IComponent
{
    // æ—¢æœ‰æ—¥å¿—è®°å½•åˆæœ‰ä¸Šä¸‹æ–‡è®¿é—®
}

// é¿å…ï¼šä¸å¿…è¦çš„å±æ€§
[Log] // âŒ é™æ€å·¥å…·ç±»é€šå¸¸ä¸éœ€è¦æ—¥å¿—
public static class MathHelper
{
    public static int Add(int a, int b) => a + b;
}
```

#### 2. å‘½åçº¦å®š

```csharp
// å¥½çš„åšæ³•ï¼šä¸€è‡´çš„å‘½å
[Log(fieldName = "Logger")]
public partial class PlayerController { }

[Log(fieldName = "Logger")]
public partial class EnemyController { }

// é¿å…ï¼šä¸ä¸€è‡´çš„å‘½å
[Log(fieldName = "Logger")]
public partial class PlayerController { }

[Log(fieldName = "CustomLogger")]
public partial class EnemyController { }
```

### ğŸ—ï¸ é¡¹ç›®ç»„ç»‡

#### 1. åˆ†ç¦»ç”Ÿæˆå™¨å’Œä¸šåŠ¡é€»è¾‘

```csharp
// å¥½çš„åšæ³•ï¼šéƒ¨åˆ†ç±»åˆ†ç¦»
// PlayerController.Logic.cs - ä¸šåŠ¡é€»è¾‘
public partial class PlayerController : IController
{
    public void Move(Vector2 direction)
    {
        if (CanMove())
        {
            UpdatePosition(direction);
            Logger.Debug($"Player moved to {direction}");
        }
    }
}

// PlayerController.Generated.cs - ç”Ÿæˆä»£ç æ‰€åœ¨
// ä¸éœ€è¦æ‰‹åŠ¨ç»´æŠ¤ï¼Œç”±ç”Ÿæˆå™¨å¤„ç†
```

#### 2. æšä¸¾è®¾è®¡

```csharp
// å¥½çš„åšæ³•ï¼šæœ‰æ„ä¹‰çš„æšä¸¾è®¾è®¡
[GenerateEnumExtensions]
public enum GameState
{
    MainMenu,    // ä¸»èœå•
    Playing,     // æ¸¸æˆä¸­
    Paused,      // æš‚åœ
    GameOver,    // æ¸¸æˆç»“æŸ
    Victory      // èƒœåˆ©
}

// é¿å…ï¼šå«ä¹‰ä¸æ˜ç¡®çš„æšä¸¾å€¼
[GenerateEnumExtensions]
public enum State
{
    State1,
    State2,
    State3
}
```

### ğŸ”§ æ€§èƒ½ä¼˜åŒ–

#### 1. é¿å…è¿‡åº¦æ—¥å¿—

```csharp
// å¥½çš„åšæ³•ï¼šåˆç†çš„æ—¥å¿—çº§åˆ«
[Log(minLevel = LogLevel.Information)]
public partial class PerformanceCriticalComponent
{
    public void Update()
    {
        // åªåœ¨å¿…è¦æ—¶è®°å½•æ—¥å¿—
        if (_performanceCounter % 1000 == 0)
        {
            Logger.Debug($"Performance: {_performanceCounter} ticks");
        }
    }
}

// é¿å…ï¼šè¿‡åº¦æ—¥å¿—è®°å½•
[Log(minLevel = LogLevel.Debug)]
public partial class NoisyComponent
{
    public void Update()
    {
        Logger.Debug($"Frame: {Engine.GetProcessFrames()}"); // å¤ªé¢‘ç¹
    }
}
```

#### 2. å»¶è¿Ÿä¸Šä¸‹æ–‡åˆå§‹åŒ–

```csharp
// å¥½çš„åšæ³•ï¼šå»¶è¿Ÿåˆå§‹åŒ–
[ContextAware(useLazy = true)]
public partial class LazyContextComponent : IComponent
{
    // åªæœ‰åœ¨ç¬¬ä¸€æ¬¡è®¿é—® Context æ—¶æ‰ä¼šåˆå§‹åŒ–
    public void Initialize()
    {
        // å¦‚æœè¿™é‡Œä¸éœ€è¦ Contextï¼Œå°±ä¸ä¼šåˆå§‹åŒ–
        SomeOtherInitialization();
    }
}
```

### ğŸ›¡ï¸ é”™è¯¯å¤„ç†

#### 1. ä¸Šä¸‹æ–‡éªŒè¯

```csharp
[ContextAware(validateContext = true)]
public partial class SafeContextComponent : IComponent
{
    public void ProcessData()
    {
        if (Context.IsInvalid)
        {
            Logger.Error("Context is invalid, cannot process data");
            return;
        }
        
        // å®‰å…¨åœ°ä½¿ç”¨ Context
        var model = Context.GetModel<DataModel>();
        // ...
    }
}
```

#### 2. å¼‚å¸¸å¤„ç†é…åˆ

```csharp
[Log]
[ContextAware]
public partial class RobustComponent : IComponent
{
    public void RiskyOperation()
    {
        try
        {
            var model = Context.GetModel<RiskyModel>();
            model.PerformRiskyOperation();
            Logger.Info("Operation completed successfully");
        }
        catch (Exception ex)
        {
            Logger.Error($"Operation failed: {ex.Message}");
            Context.SendEvent(new OperationFailedEvent { Error = ex.Message });
        }
    }
}
```

## å¸¸è§é—®é¢˜

### Q: ä¸ºä»€ä¹ˆéœ€è¦æ ‡è®°ç±»ä¸º `partial`ï¼Ÿ

**A**: æºä»£ç ç”Ÿæˆå™¨éœ€è¦å‘ç°æœ‰ç±»æ·»åŠ ä»£ç ï¼Œ`partial` å…³é”®å­—å…è®¸ä¸€ä¸ªç±»çš„å®šä¹‰åˆ†æ•£åœ¨å¤šä¸ªæ–‡ä»¶ä¸­ã€‚ç”Ÿæˆå™¨ä¼šåœ¨ç¼–è¯‘æ—¶åˆ›å»ºå¦ä¸€ä¸ªéƒ¨åˆ†ç±»æ–‡ä»¶ï¼ŒåŒ…å«ç”Ÿæˆçš„ä»£ç ã€‚

```csharp
[Log]
public partial class MyClass { } // âœ… éœ€è¦ partial

[Log]
public class MyClass { } // âŒ ç¼–è¯‘é”™è¯¯ï¼Œæ— æ³•æ·»åŠ ç”Ÿæˆä»£ç 
```

### Q: ç”Ÿæˆçš„ä»£ç åœ¨å“ªé‡Œï¼Ÿ

**A**: ç”Ÿæˆçš„ä»£ç åœ¨ç¼–è¯‘è¿‡ç¨‹ä¸­åˆ›å»ºï¼Œé»˜è®¤ä½ç½®åœ¨ `obj/Debug/net6.0/generated/` ç›®å½•ä¸‹ã€‚å¯ä»¥åœ¨é¡¹ç›®æ–‡ä»¶ä¸­é…ç½®è¾“å‡ºä½ç½®ï¼š

```xml
<PropertyGroup>
  <CompilerGeneratedFilesOutputPath>Generated</CompilerGeneratedFilesOutputPath>
</PropertyGroup>
```

### Q: å¦‚ä½•è°ƒè¯•ç”Ÿæˆå™¨é—®é¢˜ï¼Ÿ

**A**: ç”Ÿæˆå™¨æä¾›äº†è¯¦ç»†çš„è¯Šæ–­ä¿¡æ¯ï¼š

1. **æŸ¥çœ‹é”™è¯¯åˆ—è¡¨**ï¼šç¼–è¯‘é”™è¯¯ä¼šæ˜¾ç¤ºåœ¨ IDE ä¸­
2. **æŸ¥çœ‹ç”Ÿæˆæ–‡ä»¶**ï¼šæ£€æŸ¥ç”Ÿæˆçš„ä»£ç æ–‡ä»¶
3. **å¯ç”¨è¯¦ç»†æ—¥å¿—**ï¼šåœ¨é¡¹ç›®æ–‡ä»¶ä¸­æ·»åŠ ï¼š

```xml
<PropertyGroup>
  <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>
</PropertyGroup>
```

### Q: å¯ä»¥è‡ªå®šä¹‰ç”Ÿæˆå™¨å—ï¼Ÿ

**A**: å½“å‰ç‰ˆæœ¬çš„ç”Ÿæˆå™¨æ”¯æŒæœ‰é™çš„é…ç½®ã€‚å¦‚éœ€å®Œå…¨è‡ªå®šä¹‰ï¼Œå¯ä»¥åˆ›å»ºè‡ªå·±çš„æºä»£ç ç”Ÿæˆå™¨é¡¹ç›®ã€‚

### Q: æ€§èƒ½å½±å“å¦‚ä½•ï¼Ÿ

**A**: æºä»£ç ç”Ÿæˆå™¨å¯¹è¿è¡Œæ—¶æ€§èƒ½çš„å½±å“å‡ ä¹ä¸ºé›¶ï¼š

- **ç¼–è¯‘æ—¶**ï¼šå¯èƒ½ä¼šå¢åŠ ç¼–è¯‘æ—¶é—´ï¼ˆé€šå¸¸å‡ ç§’ï¼‰
- **è¿è¡Œæ—¶**ï¼šä¸æ‰‹å†™ä»£ç æ€§èƒ½ç›¸åŒ
- **å†…å­˜ä½¿ç”¨**ï¼šä¸æ‰‹å†™ä»£ç å†…å­˜ä½¿ç”¨ç›¸åŒ

### Q: ä¸ä¾èµ–æ³¨å…¥æ¡†æ¶å…¼å®¹å—ï¼Ÿ

**A**: å®Œå…¨å…¼å®¹ã€‚ç”Ÿæˆå™¨åˆ›å»ºçš„æ˜¯æ ‡å‡†ä»£ç ï¼Œå¯ä»¥ä¸ä»»ä½•ä¾èµ–æ³¨å…¥æ¡†æ¶é…åˆä½¿ç”¨ï¼š

```csharp
[Log]
[ContextAware]
public partial class ServiceComponent : IService
{
    // å¯ä»¥é€šè¿‡æ„é€ å‡½æ•°æ³¨å…¥ä¾èµ–
    private readonly IDependency _dependency;
    
    public ServiceComponent(IDependency dependency)
    {
        _dependency = dependency;
        Logger.Info("Service initialized with dependency injection");
    }
}
```

---

## ä¾èµ–å…³ç³»

```mermaid
graph TD
    A[GFramework.SourceGenerators] --> B[GFramework.SourceGenerators.Abstractions]
    A --> C[GFramework.SourceGenerators.Common]
    A --> D[GFramework.Core.Abstractions]
    A --> E[Microsoft.CodeAnalysis.CSharp]
    A --> F[Microsoft.CodeAnalysis.Analyzers]
```

## ç‰ˆæœ¬å…¼å®¹æ€§

- **.NET**: 6.0+
- **Visual Studio**: 2022 17.0+
- **Rider**: 2022.3+
- **Roslyn**: 4.0+

## è®¸å¯è¯

æœ¬é¡¹ç›®åŸºäº Apache 2.0 è®¸å¯è¯ - è¯¦æƒ…è¯·å‚é˜… [LICENSE](../LICENSE) æ–‡ä»¶ã€‚

---

**ç‰ˆæœ¬**: 1.0.0  
**æ›´æ–°æ—¥æœŸ**: 2026-01-12